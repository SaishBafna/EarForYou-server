// src/webrtc.js
import mongoose from 'mongoose';
import CallLog from '../models/Talk-to-friend/callLogModel.js';
import logger from '../logger/winston.logger.js';
import sendNotification from '../utils/sendNotification.js';
import User from '../models/Users.js';

export const setupWebRTC = (io) => {

  const users = {}; // Stores user IDs and an array of socket IDs
  const activeCalls = {}; // Track active calls between users



  io.on('connection', (socket) => {
    logger.http(`User connected: ${socket.id}`);

    socket.on('join', async ({ userId }) => {
      if (!users[userId]) {
        users[userId] = [];
      }
      users[userId].push(socket.id);
      logger.info(`User ${userId} joined with socket ID ${socket.id}`);
    });

    socket.on('call', async ({ callerId, receiverId }) => {
      logger.info(`User ${callerId} is calling User ${receiverId}`);

      // Check if the receiver is already in a call
      if (activeCalls[receiverId]) {
        socket.emit('userBusy', { receiverId });
        logger.warn(`User ${receiverId} is already in a call`);
        return;
      }

      // Fetch receiver details to get their device token for push notification
      const receiver = await User.findById(receiverId);
      const caller = await User.findById(callerId);

      if (!receiver) {
        socket.emit('userUnavailable', { receiverId });
        logger.warn(`User ${receiverId} not found`);
        return;
      }

      // Ensure users[userId] is always an array
      if (!users[callerId]) users[callerId] = [];
      if (!users[receiverId]) users[receiverId] = [];

      users[callerId].push(socket.id);

      logger.info(`Receiver's socket IDs: ${JSON.stringify(users[receiverId])}`);

      if (users[receiverId].length > 0) {
        users[receiverId].forEach((socketId) => {
          socket.to(socketId).emit('incomingCall', { callerId, socketId: socket.id });
        });
        logger.info(`Call emitted to User ${receiverId}`);

        activeCalls[callerId] = receiverId;
        activeCalls[receiverId] = callerId;

        socket.emit('playCallerTune', { callerId });


        // Send push notification if the receiver has a device token
        if (receiver.deviceToken) {
          const title = 'Incoming Call';
          const message = `${caller.username} is calling you!`;
          await sendNotification(receiver.deviceToken, title, message);
          logger.info(`Push notification sent to User ${receiverId}`);
        }
      } else {
        socket.emit('userUnavailable', { receiverId });
        logger.warn(`User ${receiverId} is unavailable for the call`);
      }
    });



    socket.on('acceptCall', async ({ receiverId, callerId }) => {
      try {
        logger.info(`User ${receiverId} accepted the call from User ${callerId}`);

        // Check if the call is active and users exist in the system
        if (activeCalls[callerId] === receiverId && users[callerId]) {
          users[callerId].forEach((socketId) => {
            if (socketId) {
              // Emit to all sockets associated with the caller
              socket.to(socketId).emit('callAccepted', { receiverId, socketId: socket.id });
            }
          });

          logger.info(`Emitted call acceptance to User ${callerId}`);

          // Stop the caller's ringing tone
          socket.emit('stopCallerTune', { callerId });
        } else {
          logger.warn(`No active call between User ${callerId} and User ${receiverId}`);
        }
      } catch (error) {
        logger.error(`Error handling call acceptance: ${error.message}`);
      }
    });
    // Handle offer from caller
    socket.on('offer', ({ offer, callerId, receiverId }) => {
      logger.info(`User ${callerId} sending offer to User ${receiverId}`);

      if (users[receiverId]) {
        users[receiverId].forEach((socketId) => {
          socket.to(socketId).emit('offer', { offer, callerId });
        });
      } else {
        socket.emit('userUnavailable', { receiverId });
        logger.warn(`User ${receiverId} not found`);
      }
    });

    // Handle answer from receiver
    socket.on('answer', ({ answer, receiverId, callerId }) => {
      logger.info(`User ${receiverId} sending answer to User ${callerId}`);

      if (users[callerId]) {
        users[callerId].forEach((socketId) => {
          socket.to(socketId).emit('answer', { answer, receiverId });
        });
      } else {
        socket.emit('userUnavailable', { callerId });
        logger.warn(`User ${callerId} not found`);
      }
    });

    // Handle ICE candidates
    socket.on('iceCandidate', ({ candidate, callerId, receiverId }) => {
      logger.info(`User ${callerId} sending ICE candidate to User ${receiverId}`);

      if (users[receiverId]) {
        users[receiverId].forEach((socketId) => {
          socket.to(socketId).emit('iceCandidate', { candidate, callerId });
        });
      } else {
        socket.emit('userUnavailable', { receiverId });
        logger.warn(`User ${receiverId} not found`);
      }
    });

    // Handle call acceptance



    socket.on('rejectCall', async ({ receiverId, callerId }) => {
      try {
        logger.info(`User ${receiverId} rejected the call from User ${callerId}`);

        // Check if the call is still active
        if (activeCalls[callerId] === receiverId) {
          // Notify the caller about the rejection
          if (users[callerId]) {
            users[callerId].forEach((socketId) => {
              socket.to(socketId).emit('callRejected', { receiverId });
            });
            logger.info(`Call rejection emitted to User ${callerId}`);
          } else {
            logger.warn(`User ${callerId} not found in users object`);
          }

          // Stop the caller tune
          socket.emit('stopCallerTune', { callerId });

          // Clean up active call status
          delete activeCalls[callerId];
          delete activeCalls[receiverId];

          // Clean up user entries if they exist
          if (users[receiverId]) delete users[receiverId];
          if (users[callerId]) delete users[callerId];
        } else {
          logger.warn(`Call between ${callerId} and ${receiverId} not found in activeCalls`);
        }

        // Create call log
        await CallLog.create({
          caller: new mongoose.Types.ObjectId(callerId),
          receiver: new mongoose.Types.ObjectId(receiverId),
          startTime: new Date(),
          endTime: new Date(),
          duration: 0,
          status: 'rejected',
        });

        logger.http(`Call log created for rejected call: Caller ${callerId}, Receiver ${receiverId}`);
      } catch (error) {
        logger.error(`Error in rejectCall handler: ${error.message}`);
        // Optionally, emit an error event to the client
        socket.emit('callError', { message: 'An error occurred while processing the call rejection' });
      }
    });

    socket.on('endCall', async ({ receiverId, callerId }) => {
      logger.info(`User ${callerId} ended the call with User ${receiverId}`);

      if (activeCalls[callerId] === receiverId) {
        users[receiverId].forEach((socketId) => {
          socket.to(socketId).emit('callEnded', { callerId });
        });
        logger.info(`Call ended emitted to User ${receiverId}`);

        // Clean up active call status
        delete activeCalls[callerId];
        delete activeCalls[receiverId];
        if (users[receiverId]) delete users[receiverId];
        if (users[callerId]) delete users[callerId];
      }

      const endTime = new Date();
      const startTime = endTime; // Adjust according to actual logic
      const duration = Math.floor((endTime - startTime) / 1000); // Duration in seconds

      await CallLog.create({
        caller: new mongoose.Types.ObjectId(callerId),
        receiver: new mongoose.Types.ObjectId(receiverId),
        startTime,
        endTime,
        duration,
        status: 'completed',
      });
      logger.http(`Call log created for completed call: Caller ${callerId}, Receiver ${receiverId}`);
    });

    socket.on('disconnect', () => {
      logger.info(`User ${socket.id} disconnected`);

      let disconnectedUserId;

      for (const [userId, socketIds] of Object.entries(users)) {
        const index = socketIds.indexOf(socket.id);
        if (index !== -1) {
          socketIds.splice(index, 1);
          disconnectedUserId = userId;
          if (socketIds.length === 0) {
            delete users[userId];
          }
          break;
        }
      }

      if (disconnectedUserId && activeCalls[disconnectedUserId]) {
        const otherUserId = activeCalls[disconnectedUserId];
        users[otherUserId]?.forEach((socketId) => {
          socket.to(socketId).emit('callEnded', { callerId: disconnectedUserId });
        });

        delete activeCalls[disconnectedUserId];
        delete activeCalls[otherUserId];
      }
    });
  });
};
